---
title: Understanding the New User Experience in Buffer
author: Julian Winternheimer
date: '2022-04-06'
slug: []
categories: []
tags: []
---

In this analysis we'll attempt to gain a better understanding of how new users interact with Buffer, identify behavior patterns that are indicative of success and share a few recommendations for how to improve the experience.

Over the course of this analysis we'll look at paid conversion rates, activation rates, the relationships between feature usage and conversion rates, session duration, upgrade paths, the distribution of the time it takes to convert, and much more. 

I'll share a brief summary of the findings in the section below if you don't want to read the entire analysis document (it's long!), but I'd recommend looking through it all when you have the time.

___

## Summary
Overall, this exploratory analysis confirms what we would suspect -- usage of Buffer's features is correlated with a higher likelihood of activating and purchasing a paid subscription. 

Usage of each feature is indicative of success, even when we try to control for users being active in general. 

There are a couple upgrade paths that have historically driven a large quantity of upgrades that are no longer performing well. Specifically, I would recommend looking more closely at these two paths and designing experiments to learn more about why they aren't performing as well:

 - `publish-composer-profileQueueLimit-showPaidPlans-1`
 - `publish-profileSidebar-addChannelButton-upgrade-1`
 
In addition to these two upgrade paths, I would recommend that we create a new upgrade path that is targeted specifically to users that want to add a team member. This is a key action that one can take and something that is highly correlated with success. 

The duration of new users' first sessions is highly correlated with success. In general, the longer they spend in the product during their first session, the more likely they are to activate and pay for a subscription. 

First session duration could be a useful early indicator of success that we can optimize for in growth experiments. 

In general, if users do not purchase a paid plan in their first 60 days, they are significantly less likely to do so in the future. The experience that new users have when signing up is highly influential and has a significant effect on their (and our) success with the product. 

___
 
```{r include = FALSE, message = FALSE, warning = FALSE}
# load libraries
library(buffer)
library(lubridate)
library(dplyr)
library(ggplot2)
library(scales)
library(tidyr)
library(skimr)
library(glmnet)
library(survival)
library(survminer)
library(ggfortify)
```
 

## Data Collection
To answer these questions, we'll collect data from over one million signups that occurred since January 1, 2021 with the SQL query below.

```{r eval = FALSE, warning = FALSE, message = FALSE}
# define sql query
sql <- "
  with users as (
    select
      u.user_id
      , u.stripe_customer_id
      , u.signup_at_date
      , date_trunc(u.signup_at_date, week) as signup_week
      , u.did_signup_from_mobile as mobile_signup
      , u.is_team_member
      , u.is_currently_trialing
      , u.did_signup_on_trial as trial_signup
      , date(min(a.timestamp)) as activated_at
      , date(min(s.first_paid_invoice_created_at)) as converted_date
      , count(distinct ss.session_id) as sessions_14_days
      , count(distinct a.id) as actions
      , count(distinct a.date) as days_active
      , count(distinct case when a.product = 'publish' then a.id end) as publish_actions
      , count(distinct case when a.product = 'analyze' then a.id end) as analyze_actions
      , count(distinct case when a.product = 'engage' then a.id end) as engage_actions
      , count(distinct case when a.product = 'start_pages' then a.id end) as sp_actions
    from dbt_buffer.buffer_users as u
    left join dbt_buffer.buffer_key_actions as a
      on u.user_id = a.user_id
      and a.timestamp >= u.signup_at
      and a.timestamp <= timestamp_add(u.signup_at, interval 14 day)
    left join dbt_buffer.stripe_paid_subscriptions as s
      on u.stripe_customer_id = s.customer_id
      and s.first_paid_invoice_created_at >= u.signup_at
    left join dbt_buffer.segment_sessions as ss
      on ss.dbt_visitor_id = u.user_id
      and ss.started_at >= u.signup_at
      and date(ss.started_at) <= date_add(u.signup_at_date, interval 14 day)
    where u.signup_at >= '2021-01-01'
    group by 1,2,3,4,5,6,7,8
  )
  
  select * from users
"

# collect data from bigquery
users <- bq_query(sql = sql)

# save data as rds object
saveRDS(users, "trial_analysis_users.rds")
```

```{r include = FALSE}
# read data
users <- readRDS("trial_analysis_users.rds") %>% 
  mutate(converted_30day = (!is.na(converted_date) & 
           as.numeric(converted_date - signup_at_date) <= 30),
         converted = !is.na(converted_date))
```

The resulting dataset includes approximately 1 million users, their signup dates, whether or not they signed up on a mobile device, whether or not they signed up from a team member invite, their activation date (the date on which they took their first key action), and several other fields related to their activity in the first 14 days after signing up for Buffer.

We can get a glimpse of the dataset using the `glimpse()` command below.

```{r}
# preview dataset
glimpse(users)
```

## 30-Day Conversion Rates
We'll begin with a bit of exploratory analysis. We'd like to have a better understanding of the effect that starting new users on a trial has, so we'll calculate the proportion of free and trial signups that subscribed to a paid plan within 30 days of signup. 

The proportions below only include people that signed up on the web app, since people that sign up on the mobile apps do not have the option of starting a trial when they sign up.

```{r warning = FALSE, message = FALSE}
# calculate 30-day conversion rates
users %>% 
  filter(signup_week < "2022-03-01" & (is.na(mobile_signup) | !mobile_signup)) %>% 
  group_by(trial_signup, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = percent(users / sum(users), accuracy = 0.01)) %>% 
  filter(converted_30day)
```

Unsurprisingly people that have decided to sign up on a trial have converted to paid plans at a much higher rate than those that have signed up on a free plan. There is likely some selection bias at play here. If we put all signups on to a trial, it's likely that the 30-day conversion rate will fall somewhere in between these two rates.


Next we'll plot these conversion rates over time, grouping by the week in which people signed up. The plot below shows us that the conversion rates have remained relatively stable over time, with a slight positive trend. 

The 30-day conversion rate for people that sign up on a trial has been consistently higher than that of people that sign up on a Free plan.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversion rates over time
users %>% 
  filter((is.na(mobile_signup) | !mobile_signup)) %>% 
  group_by(signup_week, trial_signup, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users)) %>% 
  filter(converted_30day & signup_week < "2022-03-01") %>% 
  buffplot(aes(x = signup_week, y = percent, color = trial_signup)) +
  geom_line() +
  scale_y_continuous(labels = percent) +
  labs(x = "Signup Week", y = "30-Day Conversion Rate",
       color = "Trial Signup")
```


## Distribution of Time to Conversion
The next thing we'll cover is the distribution of the number of days it takes new signups to convert to a paid plan. We'll start by calculating the quantiles of the number of days to convert for both free and trial signups.

```{r}
# define quantiles of interest
q = c(.25, .5, .75)

#calculate quantiles by grouping variable
users %>%
  filter(converted & (is.na(mobile_signup) | !mobile_signup)) %>% 
  mutate(days_to_convert = as.numeric(converted_date - signup_at_date)) %>% 
  group_by(trial_signup) %>%
  summarize(quant25 = quantile(days_to_convert, probs = q[1]), 
            quant50 = quantile(days_to_convert, probs = q[2]),
            quant75 = quantile(days_to_convert, probs = q[3]))
```

These quantiles show us that the median number of days to convert is 14 days for trial signups and 18 days for free signups, which is logical. As of April 2022, Buffer trials are 14 days in length, and many people that subscribe to paid plan do so on the day that their trials expire. 

It's interesting to note that over a quarter of users that convert do so by their second day.

The plot below visualizes distribution of the number of days to convert below.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# calculate quantiles by grouping variable
users %>%
  filter(converted & (is.na(mobile_signup) | !mobile_signup)) %>% 
  mutate(days_to_convert = as.numeric(converted_date - signup_at_date)) %>% 
  filter(days_to_convert >= 0) %>% 
  group_by(trial_signup, days_to_convert) %>% 
  summarise(customers = n_distinct(stripe_customer_id)) %>% 
  mutate(percent = customers / sum(customers)) %>% 
  buffplot(aes(x = days_to_convert, y = percent, fill = trial_signup)) +
  geom_col(show.legend = TRUE) +
  scale_x_continuous(limits = c(0, 60)) +
  facet_wrap(~trial_signup, nrow = 1) +
  scale_y_continuous(labels = percent, limits = c(0, 0.15)) +
  labs(x = "Days to Convert", y = "Percent of Conversions", fill = "Trial Signup")
```

A higher proportion of free signups convert on the day that they sign up, and more conversions are clustered around the 14-day mark (the length of the trial) for those that sign up on a trial. 

Another way to visualize the distributions of the number of days it takes people to convert is to plot the cumulative distribution functions (CDFs) for these two populations.

```{r echo = FALSE , warning = FALSE, message = FALSE}
# plot CDFs
users %>%
  filter(converted & (is.na(mobile_signup) | !mobile_signup)) %>% 
  mutate(days_to_convert = as.numeric(converted_date - signup_at_date)) %>% 
  filter(days_to_convert >= 0) %>% 
  buffplot(aes(x = days_to_convert, color = trial_signup)) +
  stat_ecdf() +
  coord_cartesian(xlim = c(0, 60)) +
  scale_x_continuous(limits = c(0, 60), breaks = seq(0, 60, 14)) +
  scale_y_continuous(labels = percent, breaks = seq(0, 1, 0.2)) +
  labs(x = "Days to Convert", y = "Percent of Conversions", color = "Trial Signup")
```

Each point on the line represents the proportion of conversions that occurred in X days _or fewer_. For example, at X = 14 we can see that approximately 64% of trial signups have converted (implying that approximately 36% of conversions take longer than 14 days) and 58% of free signups have converted. This principle can be applied to any point on the curve. We can see that by day 60 most people that will convert have converted.

This doesn't quite give us a complete picture though. The plots above only include users that have subscribed to a paid plan and the data is [right censored](https://reliability.readthedocs.io/en/latest/What%20is%20censored%20data.html#:~:text=Censored%20data%20is%20any%20data,referred%20to%20as%20complete%20data.), meaning there are some users that will convert that haven't yet done so.

One useful technique for dealing with censored data is [survival analysis](https://en.wikipedia.org/wiki/Survival_analysis).


## Survival Analysis
Because a greater proportion of trialists end up converting, it could be worth using survival analysis techniques to visualize the amount of time it takes to convert.

The survival probability at a certain time, S(t), is a conditional probability of surviving (i.e. not converting) beyond that time, given that an individual hasn't converted just prior to that time.

The Kaplan-Meier method is the most common way to estimate survival times and probabilities. It is a non-parametric approach that results in a step function, where there is a step down each time an event occurs. 

A Kaplan-Meier plot is included below for both free and trial signups.

```{r echo = FALSE}
# set status column
users <- users %>% 
  mutate(status = ifelse(converted, 1, 0),
         time = ifelse(
           converted, as.numeric(converted_date - signup_at_date),
           as.numeric(Sys.Date() - signup_at_date)))

# fit survival curve
fit.surv <- survfit(Surv(time, status) ~ trial_signup, data = users)
```

```{r echo = FALSE, message = FALSE, warning = FALSE}
# plot survival curve
autoplot(fit.surv, censor = TRUE, censor.size = 1) +
  scale_x_continuous(limits = c(0, 365), breaks = seq(0, 365, 60)) +
  scale_y_continuous(labels = percent) +
  labs(x = "Days Since Signing Up", y = "Estimated % That Hasn't Converted",
       title = "Survival Curve of Time to Convert",
       color = "Trial Signup",
       fill = "Trial Signup")
```

Each point on the graph represents the proportion of the population that _hasn't_ converted after X days. The inverse would be the proportion that had converted by day X.

The plot tells us a couple things. The first, which we already knew, is that people that sign up with trials convert at much higher rates that don't. The second, and perhaps more important, thing is that the first 60 days after signing up are crucial for those that convert.

There is a long tail of people that convert after the 60 day mark, but it is significantly less likely for any given user to convert if they haven't done so by their 60th day.


## Session Counts and Conversion
The next thing we'll look at is the relationship between session counts and paid conversion. We'll use a similar approach to calculate quantiles of the number of sessions in the first 14 days for free and trial users.

```{r}
# quantiles of interest
q = c(.25, .5, .75)

# calculate quantiles by grouping variable
users %>%
  filter(is.na(mobile_signup) | !mobile_signup) %>% 
  mutate(days_to_convert = as.numeric(converted_date - signup_at_date)) %>% 
  group_by(converted) %>%
  summarize(quant25 = quantile(sessions_14_days, probs = q[1]), 
            quant50 = quantile(sessions_14_days, probs = q[2]),
            quant75 = quantile(sessions_14_days, probs = q[3]))
```

These quantiles tell that there is a significant difference in the number of sessions that users who convert and don't convert have in their first 14 days. This is to be expected, as more engaged users are more likely to have more sessions and convert.

The plot below shows the distribution of the number of sessions users had in their first 14 days for four distinct populations:

 - Users that signed up on a free plan and converted
 - Users that signed up with a trial and converted
 - Users that signed up on a free plan and didn't convert
 - Users that signed up with a trial and didn't convert
 
We can see that for all signups, the distribution of the number of sessions is shifted to the right for those that ended up converting. 

Users that convert to paid plans generally have more sessions in their first 14 days. The largest bucket of converted users had 10-25 sessions in their first 2 weeks.


```{r warning = FALSE, message = FALSE, ecgo = FALSE}
# define breakpoints 
breakpoints <- c(-Inf, 0, 1, 5, 10, 25, 50, Inf)

# plot distributions
users %>%
  filter(is.na(mobile_signup) | !mobile_signup) %>% 
  mutate(session_bucket = cut(sessions_14_days, breaks = breakpoints),
         type = case_when(
          converted & trial_signup ~ "converted_trial",
          converted & !trial_signup ~ "converted_free",
          !converted & trial_signup ~ "no_conversion_trial",
          !converted & !trial_signup ~ "no_conversion_free",
          TRUE ~ "unknown"
  )) %>% 
  group_by(type, session_bucket) %>%
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users)) %>% 
  buffplot(aes(x = session_bucket, y = percent, fill = type)) +
  geom_col(show.legend = F) +
  facet_wrap(~type) +
  scale_y_continuous(labels = percent) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) +
  labs(x = "Sessions First 14 Days", y = "Percent of Users")
```

The plot below shows the conversion rates for users that had certain numbers of sessions in their first 14 days.

```{r echo = FALSE, message = FALSE, warning = FALSE}
# plot conversion rate by session count
users %>%
  filter(is.na(mobile_signup) | !mobile_signup) %>% 
  mutate(session_bucket = cut(sessions_14_days, breaks = breakpoints)) %>% 
  group_by(session_bucket, converted) %>%
  summarise(users = n_distinct(user_id)) %>% 
  mutate(prop = users / sum(users)) %>% 
  filter(converted) %>% 
  buffplot(aes(x = session_bucket, y = prop)) +
  geom_col(show.legend = F) +
  scale_y_continuous(labels = percent) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) +
  labs(x = "Sessions First 14 Days", y = "Conversion Rate")
```

We can see that there is a clear correlation between the number of sessions in users' first 14 days and the likelihood of converting to a paid subscription.

Next we'll look at some of the differences between people that sign up on web and those that sign up on one of the mobile apps.


## Web and Mobile Signups
It's important to note that by "mobile" we only refer to those that signed up on one of the mobile apps. People that sign up on a mobile web browser are still considered "web" signups.

The first thing we'll look at is the 30-day conversion rate for web and mobile signups.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversion rates over time
users %>% 
  filter(!is.na(mobile_signup)) %>% 
  group_by(signup_week, mobile_signup, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users)) %>% 
  filter(converted_30day & signup_week < "2022-03-01") %>% 
  buffplot(aes(x = signup_week, y = percent, color = mobile_signup)) +
  geom_line() +
  scale_y_continuous(labels = percent) +
  labs(x = "Signup Week", y = "30-Day Conversion Rate",
       color = "Mobile Signup")
```

30-day conversion rates are generally much lower for people that sign up on mobile. Let's now compare conversion rates for web users that signed up without a trial.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversion rates over time
users %>% 
  filter(!is.na(mobile_signup) & !trial_signup) %>% 
  group_by(signup_week, mobile_signup, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users)) %>% 
  filter(converted_30day & signup_week < "2022-03-01") %>% 
  buffplot(aes(x = signup_week, y = percent, color = mobile_signup)) +
  geom_line() +
  scale_y_continuous(labels = percent) +
  labs(x = "Signup Week", y = "30-Day Conversion Rate",
       caption = "Free Signups Only",
       color = "Mobile Signup")
```

We can see that the conversion rates are much closer, but, overall, people that sign up on the mobile apps convert at lower rates than those that sign up on web.

Next we'll explore Buffer's key actions and their relationships to paid conversions.

## Key Actions and Upgrades
First we'll calculate the correlation coefficients for each of the key actions and whether or not a user converted.

```{r include = FALSE, warning = FALSE, message = FALSE}
# add boolean values for using products
users <- users %>% 
  mutate(used_publish = publish_actions > 0,
         used_engage = engage_actions > 0,
         used_analyze = analyze_actions > 0,
         used_sp = sp_actions > 0)
```

```{r warning = FALSE, message = FALSE}
# filter data
filtered <- users %>% select(converted, publish_actions:sp_actions)

# create correlation matrix
m <- cor(filtered)

# view matrix
head(round(m, 2))
```

We can see that the correlations are quite low, but this could be because the variance of the number of actions is quite high. 

For example, the plot below shows the cumulative distribution function (CDF) for the number of publishing actions taken in the first 14 days for people that converted and people that didn't. There's a large range for the `publish_actions` variable -- scaling the action counts might lead to more instructive correlation coefficients.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot dist of publish actions
users %>% 
  buffplot(aes(x = publish_actions, color = converted)) +
  stat_ecdf() +
  coord_cartesian(xlim = c(0, 500))
```

The plot below shows the relative conversion rates for those that did and didn't use certain products in their first two weeks. We can see that users that use Analyze or Engage tend to convert at higher rates, but not using those features doesn't necessarily mean that there's a low chance of conversion.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# filter data
filtered <- users %>% select(user_id, converted_30day:used_sp)

# pivot to long format
rates <- filtered %>% 
  rename(publish = used_publish,
         engage = used_engage,
         analyze = used_analyze,
         start_page = used_sp) %>% 
  pivot_longer(publish:start_page,
               names_to = "product",
               values_to = "did_use") %>% 
  group_by(product, did_use, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users))

# plot conversion rates by whether used
rates %>% 
  filter(converted_30day) %>% 
  buffplot(aes(x = did_use, y = percent, fill = product)) +
  geom_col(show.legend = F) +
  facet_wrap(~product) +
  scale_y_continuous(labels = percent, breaks = seq(0, 25, 0.05)) +
  labs(x = "Used in First 14 Days", y = "Conversion Rate")
```

We can also group the number of actions taken in each product to visualize the correlations.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# filter data
filtered <- users %>% select(user_id, converted_30day, publish_actions:sp_actions)

# define breakpoints
breakpoints <- c(-Inf, 0, 5, 10, 25, 50, 100, Inf)

# pivot to long format
rates <- filtered %>% 
  rename(publish = publish_actions,
         engage = engage_actions,
         analyze = analyze_actions,
         start_page = sp_actions) %>% 
  pivot_longer(publish:start_page,
               names_to = "product",
               values_to = "actions") %>% 
  mutate(action_bucket = cut(actions, breaks = breakpoints)) %>% 
  group_by(product, action_bucket, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users))

# plot conversion rates by whether used
rates %>% 
  filter(converted_30day) %>% 
  buffplot(aes(x = action_bucket, y = percent, fill = product)) +
  geom_col(show.legend = F) +
  facet_wrap(~product, scales = "free_y") +
  scale_y_continuous(labels = percent) +
  labs(x = "Actions in First 14 Days", y = "Conversion Rate") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5))
```

The plots above show that there are indeed correlations between the number of key actions taken and conversion rates. This is all intuitive -- users that are engaged and more active in the product are more likely to convert. Additionally, users that convert within the first 14 days are more likely to take more actions.

In the next section we'll try to get a better understanding of the individual importance of each feature. One way to do that is to fit a model containing all p predictors and use a technique that constrains or regularizes the coefficient estimates, or equivalently, that shrinks the coefficient estimates towards zero. 

The two best-known techniques for shrinking the regression coefficients towards zero are ridge regression and the lasso. Each method utilizes a shrinkage penalty which has the effect of shrinking the estimates of βj towards zero when the coefficients themselves are close to 0. 

The tuning parameter λ serves to control the relative impact of these two terms on the regression coefficient estimates. When λ = 0, the penalty term has no effect, and ridge regression will produce the least squares estimates. However, as λ → ∞, the impact of the shrinkage penalty grows, and the ridge regression coefficient estimates will approach zero.

While ridge regression shrinks the coefficient estimates towards 0, Lasso regressions actually shrinks the coefficients to exactly 0, which is a form of variable selection. It's generally useful when multicollinearity is present and one wants to get a better understanding of which predictors are most important.


## Lasso Regression
Simply put, lasso regression shrinks the coefficients of predictors to 0 if they don't explain a sufficient amount of the variance in the response.

A lasso regression model is fit with the simple command below. 

```{r include = FALSE, warning = FALSE, message = FALSE}
# set new column
users <- users %>% mutate(response = ifelse(converted_30day, 1, 0))

# define response variable
y <- users$response

# define matrix of predictor variables
features <- users %>% 
  dplyr::select(mobile_signup, is_team_member, trial_signup,
                sessions_14_days, actions, days_active,used_publish, 
                used_engage, used_analyze, used_sp)

# turn strings into factors
features <- as.data.frame(unclass(features), stringsAsFactors = TRUE)

# create matrix
x <- as.matrix(features)
```

```{r}
# fit lasso regression model
mod <- cv.glmnet(x, y, alpha = 1)

# plot model
plot(mod)

# get best lambda value
bestlam <- mod$lambda.min

# show coefficients
predict(mod, type = "coefficients", s = bestlam)
```

We can see that the coefficients for `mobile_signup` and `is_team_member` have been shrunk to 0. The rest of the features may have some predictive value, however more time should be spent on feature engineering and model tuning than we have to complete this analysis. 


## Number of Days Active and Conversion
One of the coefficients remaining in the lasso regression model was `days_active`, which refers to the number of days in which a key action was taken during the 14 days after signup. 

The plot below shows the number of days active on the x-axis and the conversion rate on the y-axis. We can see that there is a relationship, though it isn't completely linear. Users that are active around 7 days are more likely to convert, and users that are active every day are very likely to convert.

We have to remember that the actions could have been taken _after_ users convert, so there might be some reverse causality here.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversion rate by days active
users %>% 
  group_by(trial_signup, days_active, converted_30day) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(prop = users / sum(users)) %>% 
  filter(converted_30day) %>% 
  buffplot(aes(x = days_active, y = prop, fill = trial_signup)) +
  geom_col(show.legend = F) +
  facet_wrap(~trial_signup, scales = "free_y") +
  labs(x = "Days Active in First 14 Days", y = "Conversion Rate",
       fill = "Trial Signup") +
  scale_y_continuous(labels = percent)
```

Next we'll shift gears and look at activation, which is defined as having taken one's first key action.

## Frequency of Login and Activation
The first thing we'll look at is how frequency of login relates to the likelihood of activated. The data could be muddled because some users activate quickly, and activated users are more likely to log in. Additionally [80% of users that activate in their first 7 days do so within 12 hours of signing up](https://mixpanel.com/s/2HgEX). 

We'll use the query below to collect activation-related data for over one million Buffer users.

```{r eval = FALSE, warning = FALSE, message = FALSE}
# define sql query
sql <- "
  with users as (
    select
      u.user_id
      , u.stripe_customer_id
      , u.signup_at_date
      , date_trunc(u.signup_at_date, week) as signup_week
      , u.did_signup_from_mobile as mobile_signup
      , u.is_team_member
      , u.is_currently_trialing
      , u.did_signup_on_trial as trial_signup
      , date(min(a.timestamp)) as activated_at
      , date(min(s.first_paid_invoice_created_at)) as converted_date
      , count(distinct ss.session_id) as signup_sessions
      , avg(ss.n_events) as avg_sesh_events
      , avg(ss.session_duration_minutes) as avg_sesh_duration
    from dbt_buffer.buffer_users as u
    left join dbt_buffer.buffer_key_actions as a
      on u.user_id = a.user_id
      and a.timestamp >= u.signup_at
      and a.timestamp <= timestamp_add(u.signup_at, interval 14 day)
    left join dbt_buffer.stripe_paid_subscriptions as s
      on u.stripe_customer_id = s.customer_id
      and s.first_paid_invoice_created_at >= u.signup_at
    left join dbt_buffer.segment_sessions as ss
      on ss.dbt_visitor_id = u.user_id
      and ss.signup_session
      and date(ss.started_at) = date(u.signup_at)
    where u.signup_at >= '2021-01-01'
    group by 1,2,3,4,5,6,7,8
  )
  
  select * from users
"

# collect data from bigquery
activations <- bq_query(sql = sql)

# save data
saveRDS(activations, "trial_analysis_activations.rds")
```

```{r include = FALSE}
# read data
activations <- readRDS("trial_analysis_activations.rds") %>% 
  mutate(activated_day1 = as.numeric(converted_date - signup_at_date) <= 1 &
           !is.na(converted_date))
```

The output below shows the quantiles for average session duration for users that did and didn't activate _in their first day_. The average session duration refers only to the session in which the users signed up.

```{r}
# calculate quantiles by grouping variable
activations %>%
  filter(!is.na(avg_sesh_duration)) %>% 
  group_by(activated_day1) %>%
  summarize(quant25 = quantile(avg_sesh_duration, probs = q[1]), 
            quant50 = quantile(avg_sesh_duration, probs = q[2]),
            quant75 = quantile(avg_sesh_duration, probs = q[3]))
```

Those that activated on their first day tended to have much longer first sessions. The median session duration was 26 minutes, compared to 5 minutes for those that didn't activate. 

Let's now look at the number of events that occur in the first session.

```{r}
# calculate quantiles by grouping variable
activations %>%
  filter(!is.na(avg_sesh_events)) %>% 
  group_by(activated_day1) %>%
  summarize(quant25 = quantile(avg_sesh_events, probs = q[1]), 
            quant50 = quantile(avg_sesh_events, probs = q[2]),
            quant75 = quantile(avg_sesh_events, probs = q[3]))
```

Again, users that activated in their first day tended to have more events in their first session, which is logical.

The plot below shows the activation rates for certain session duration buckets. We can see that there's a large increase in the activation rate for those whose first session was at least 10 minutes.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# define breakpoints
cuts <- c(0, 1, 5, 10, 30, 60, 90, Inf)

# plot distribution of session length
activations %>%
  filter(!is.na(avg_sesh_duration)) %>% 
  mutate(duration_bucket = cut(avg_sesh_duration, breaks = cuts)) %>% 
  filter(!is.na(duration_bucket)) %>% 
  group_by(activated_day1, duration_bucket) %>% 
  summarise(users = n_distinct(user_id)) %>%
  mutate(prop = users / sum(users)) %>% 
  buffplot(aes(x = duration_bucket, y = prop, fill = activated_day1)) +
  geom_col(show.legend = F) +
  facet_wrap(~activated_day1) +
  scale_y_continuous(labels = percent) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) +
  labs(x = "First Session Duration", y = "Proportion of Users", 
       subtitle = "Activated on First Day")
```

The plot below shows the total activation rate by first session length for each user. It's clear that first session length is highly correlated with activation.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# define breakpoints
cuts <- c(0, 1, 5, 10, 30, 60, 90, Inf)

# plot distribution of session length
activations %>%
  filter(!is.na(avg_sesh_duration)) %>% 
  mutate(duration_bucket = cut(avg_sesh_duration, breaks = cuts)) %>% 
  filter(!is.na(duration_bucket)) %>% 
  group_by(duration_bucket, activated_day1) %>% 
  summarise(users = n_distinct(user_id)) %>%
  mutate(prop = users / sum(users)) %>% 
  filter(activated_day1) %>% 
  buffplot(aes(x = duration_bucket, y = prop)) +
  geom_col(show.legend = F) +
  scale_y_continuous(labels = percent) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) +
  labs(x = "First Session Duration", y = "Proportion of Users", 
       subtitle = "Activated on First Day")
```

Next we'll extend this to look at the relationship between first session length and the likelihood of converting to a paid subscription. Again we see that there's a strong correlation present.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# join session length
sesh_length <- activations %>% select(user_id, avg_sesh_duration)

# join to users
users <- users %>% 
  left_join(sesh_length, by = "user_id")

# plot distribution of session length
users %>%
  filter(!is.na(avg_sesh_duration)) %>% 
  mutate(duration_bucket = cut(avg_sesh_duration, breaks = cuts)) %>% 
  filter(!is.na(duration_bucket)) %>% 
  group_by(duration_bucket, converted) %>% 
  summarise(users = n_distinct(user_id)) %>%
  mutate(prop = users / sum(users)) %>% 
  filter(converted) %>% 
  buffplot(aes(x = duration_bucket, y = prop)) +
  geom_col(show.legend = F) +
  scale_y_continuous(labels = percent) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) +
  labs(x = "First Session Duration", y = "Proportion of Users", 
       subtitle = "Converted to Paid Subscription")
```

In the next session we'll shift gears again and look at specific upgrade paths within Buffer's products.

## Upgrade Paths
The data used in the analysis below comes from [this Mixpanel report](https://mixpanel.com/s/4DPzTa) and only includes upgrade paths that have been defined in the `Upgrade Path Viewed` tracking event.

```{r include = FALSE, warning = FALSE, message = FALSE, eval = FALSE}
library(readr)

# read csv
paths <- read_csv("~/Desktop/upgrade_paths.csv")

# clean data
names(paths) <- c("week", "upgrade_path", "views", "conversions")

# remove $ character
paths$upgrade_path <- gsub("\\$", "", paths$upgrade_path)

# save data
saveRDS(paths, "upgrade_paths.rds")
```

```{r include = FALSE}
# read data
paths <- readRDS("upgrade_paths.rds")
```

We'll start by looking at the number of conversions each path drives each week. All of the conversions must occur within 7 days of viewing the upgrade path.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter(upgrade_path != "overall" & 
           upgrade_path != "app-shell-userMenu-upgrade" &
           week >= "2021-07-01") %>% 
  mutate(upgrade_path = reorder(upgrade_path, -conversions)) %>% 
  buffplot(aes(x = week, y = conversions, color = upgrade_path)) +
  geom_line(size = 0.8) +
  facet_wrap(~upgrade_path, scales = "free_y") +
  theme(legend.position = "none") +
  labs(x = "Week", y = "Conversions")
```

The upgrade path that stands out most clearly is `publish-profile-nav-tabNavigation-upgrade-1`. At one point it was driving over 200 upgrades per week, but it has since been changed to a prompt to start a trial. Now it drives only 5-15 upgrades per week.  

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter(upgrade_path == "publish-profile-nav-tabNavigation-upgrade-1") %>% 
  buffplot(aes(x = week, y = conversions)) +
  geom_line(size = 0.8) +
  theme(legend.position = "none") +
  labs(x = "Week", y = "Conversions", 
       title = "Conversions by Upgrade Path",
       subtitle = "Publish Nav Upgrade Button")
```

Another one that stands out is `publish-profileSidebar-addChannelButton-upgrade-1`. Upgrades from this path have also decreased by over 50%. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter(upgrade_path == "publish-profileSidebar-addChannelButton-upgrade-1") %>% 
  buffplot(aes(x = week, y = conversions)) +
  geom_line(size = 0.8) +
  theme(legend.position = "none") +
  labs(x = "Week", y = "Conversions", 
       title = "Conversions by Upgrade Path",
       subtitle = "Publish Sidebar Add Channel Button")
```

**_I would strongly recommend testing those upgrade paths. Specifically, I would run an A/B test to measure the effect of changing it from a trial prompt to a direct upgrade path_**.

Next let's look at the conversion rates of each upgrade path. The conversion rate is just the proportion of users that viewed an upgrade path and converted within 7 days of that event.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter(upgrade_path != "overall" & 
           upgrade_path != "app-shell-userMenu-upgrade" &
           week >= "2021-07-01") %>% 
  mutate(rate = conversions / views,
         upgrade_path = reorder(upgrade_path, -rate)) %>% 
  buffplot(aes(x = week, y = rate, color = upgrade_path)) +
  geom_line(size = 0.8) +
  scale_y_continuous(labels = percent) +
  facet_wrap(~upgrade_path, scales = "free_y") +
  theme(legend.position = "none") +
  labs(x = "Week", y = "Conversion Rate")
```

Here are the top upgrade paths by conversion rate:

 - Queue limit
 - Campaigns empty state
 - Awaiting approval paywall
 - Top nav upgrade button
 - Add channel button
 - Hashtag manager path
 - Drafts paywall
 
We'll isolate a couple of these in the section below.
 
 
## Queue Limit and Channel Limit Upgrade Paths
These upgrade paths have the highest conversion rates. Both are based on activity -- the queue limit upgrade path is displayed when free users schedule too many posts, and the channel limit upgrade path is diplayed when people connect more channels than what's allowed.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter((upgrade_path == "publish-composer-profileQueueLimit-showPaidPlans-1" |
           upgrade_path == "publish-profileSidebar-addChannelButton-upgrade-1") &
           week <= "2022-04-01") %>% 
  buffplot(aes(x = week, y = views, color = upgrade_path)) +
  geom_line(size = 0.8) +
  labs(x = "Week", y = "Upgrade Path Viewers", 
       title = "Upgrade Path Viewers",
       subtitle = "Queue Limit and Channel Connection",
       color = NULL)
```

Many more users view the channel limit upgrade path, which is why it drives more conversions. The plot below shows the number of weekly conversions that each upgrade path drives.
 
```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter((upgrade_path == "publish-composer-profileQueueLimit-showPaidPlans-1" |
           upgrade_path == "publish-profileSidebar-addChannelButton-upgrade-1") &
           week <= "2022-04-01") %>% 
  buffplot(aes(x = week, y = conversions, color = upgrade_path)) +
  geom_line(size = 0.8) +
  labs(x = "Week", y = "Upgrade Path Conversions", 
       title = "Upgrade Path Conversions",
       subtitle = "Queue Limit and Channel Connection",
       color = NULL)
```

In the section below we'll attempt to answer a specific question about the role that the user limit plays in converting people to paid subscribers.

## User Limit Upgrade Path
As of April 2022 we're not tracking a distinct upgrade path for the 1-user limit. I'd recommend tracking this upgrade path if it exists, and if it doesn't I'd recommend creating one. 

Right now the closest upgrade path we have would probably be `publish-awaitingApproval-paywall-upgrade-1`. 

```{r echo = FALSE, warning = FALSE, message = FALSE}
# plot conversions by upgrade path
paths %>% 
  filter((upgrade_path == "publish-awaitingApproval-paywall-upgrade-1") &
           week <= "2022-04-01") %>% 
  buffplot(aes(x = week)) +
  geom_line(aes(y = views, color = "Views"), size = 0.8) +
  geom_line(aes(y = conversions, color = "Conversions"), size = 0.8) +
  labs(x = "Week", y = "Users", 
       title = "Upgrade Path Conversions",
       subtitle = "Awaiting Approval Upgrade Path",
       color = NULL)
```


## Role of Analyze and Engage During Trial
Next we'll look at the role analyze and engage play during trials. The data used in this section of the analysis is gathered with the following SQL query. The data includes 180K trials started since September 2021 (after the New Buffer launch).

```{r eval = FALSE, warning = FALSE, message = FALSE}
# define sql query
sql <- "
  select
    t.id as trial_id
    , t.trial_started_at
    , t.subscription_id
    , t.customer_id
    , t.plan_id
    , t.metadata_user_id as trial_user_id
    , t.has_converted as converted
    , count(distinct a.id) as actions
    , count(distinct case when a.product = 'publish' then a.id end) as pub_actions
    , count(distinct case when a.product = 'engage' then a.id end) as engage_actions
    , count(distinct case when a.product = 'analyze' then a.id end) as analyze_actions
  from dbt_buffer.stripe_trials as t
  left join dbt_buffer.buffer_key_actions as a
    on t.metadata_user_id = a.user_id
    and a.timestamp > t.trial_started_at
    and a.timestamp < timestamp_add(t.trial_started_at, interval 14 day)
  where t.trial_started_at >= '2021-09-01'
  group by 1,2,3,4,5,6,7
"

# collect data from bigquery
trials <- bq_query(sql = sql)

# save data
saveRDS(trials, "trial_analysis_trials.rds")
```

```{r include = FALSE}
# read data
trials <- readRDS("trial_analysis_trials.rds")

# determine if active
trials <- trials %>% 
  mutate(active = actions >= 1,
         publish_active = pub_actions > 0,
         analyze_active = analyze_actions > 0,
         engage_active = engage_actions > 0) 
```

One quick approach we could take is to fit a logistic regression model to see if using each of the features is correlated with trial conversion _given that the user was active during trial_. It's important to note that there's likely collinearity, which is why some regularization or feature selection cpuld be important. 

For this exploratory analysis we'll only look at the model coefficients without regularization or further feature engineering.

```{r}
# fit logistic regression model
mod <- glm(converted ~ active + publish_active + engage_active + analyze_active,
           data = trials, family = "binomial")

# summarize model
summary(mod)
```

The model output suggests that use of each feature is correlated with trial conversion. We can try using lasso regression again to see if any of the features can be dropped from the model.

```{r echo = FALSE, message = FALSE, include = FALSE}
# set new column
trials <- trials %>% mutate(response = ifelse(converted, 1, 0))

# define response variable
y <- trials$response

# define matrix of predictor variables
features <- trials %>% 
  dplyr::select(active:engage_active)

# turn strings into factors
features <- as.data.frame(unclass(features), stringsAsFactors = TRUE)

# create matrix
x <- as.matrix(features)
```

```{r}
# fit lasso regression model
mod <- cv.glmnet(x, y, alpha = 1)

# summarize model
coef(mod)
```

All features are correlated with conversion, which isn't surprising. However, using the publishing feature seems to be indicative of a much greater likelihood of converting.

The plot below shows the relative conversion rates for trialists that did and didn't use each feature.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# filter data
filtered <- trials %>% select(customer_id, converted, active:engage_active)

# pivot to long format
rates <- filtered %>% 
  rename(publish = publish_active,
         engage = engage_active,
         analyze = analyze_active,
         all_buffer = active) %>% 
  pivot_longer(all_buffer:engage,
               names_to = "product",
               values_to = "did_use") %>% 
  group_by(product, did_use, converted) %>% 
  summarise(users = n_distinct(customer_id)) %>% 
  mutate(percent = users / sum(users))

# plot conversion rates by whether used
rates %>% 
  filter(converted) %>% 
  buffplot(aes(x = did_use, y = percent, fill = product)) +
  geom_col(show.legend = F) +
  facet_wrap(~product) +
  scale_y_continuous(labels = percent) +
  labs(x = "Used During Trial", y = "Conversion Rate")
```


## Role of Analyze and Engage For Free Signups
Finally we'll look at the correlations between using Analyze and Engage and paid conversions for users that sign up on a free plan. 

We'll use the query below to gather the number of times free users used Analyze and Engage in their first 14 days after signing up (or before converting if they did convert). There are about 61 thousand users in total.

```{r eval = FALSE, warning = FALSE, message = FALSE}
# define sql query
sql <- "
  with first_sub as (
    select
      c.user_id
      , c.timestamp as signup_at
      , date(c.timestamp) as signup_date
      , count(distinct s.id) > 0 as converted
      , min(s.first_paid_invoice_created_at) as converted_at
    from dbt_buffer.segment_accounts_created as c
    left join dbt_buffer.stripe_paid_subscriptions as s
      on s.account_id = c.user_id
      and s.first_paid_invoice_created_at >= c.timestamp
    where not c.created_with_trial
    group by 1,2,3
  )
  select
    f.user_id
    , f.signup_at
    , f.signup_date
    , f.converted
    , f.converted_at
    , count(distinct a.id) as actions
    , count(distinct case when a.product = 'publish' then a.id end) as pub_actions
    , count(distinct case when a.product = 'engage' then a.id end) as engage_actions
    , count(distinct case when a.product = 'analyze' then a.id end) as analyze_actions
  from first_sub as f
  left join dbt_buffer.buffer_key_actions as a
    on f.user_id = a.user_id
    and a.timestamp > f.signup_at
    and a.timestamp < timestamp_add(f.signup_at, interval 14 day)
    and (a.timestamp < f.converted_at or f.converted_at is null)
  group by 1,2,3,4,5
"

# collect data from bigquery
free <- bq_query(sql = sql)

# save data
saveRDS(free, "trial_analysis_free.rds")
```

```{r include = FALSE}
# read data
free <- readRDS("trial_analysis_free.rds")

# determine if active
free <- free %>% 
  mutate(active = actions >= 1,
         publish_active = pub_actions > 0,
         analyze_active = analyze_actions > 0,
         engage_active = engage_actions > 0) 
```

We'll fit another logistic regression model to see if using each of the features is correlated with paid conversion _given that the user was active_. It's important to note that there's likely collinearity, which is why some regularization or feature selection is important.

```{r}
# fit logistic regression model
mod <- glm(converted ~ active + publish_active + engage_active + analyze_active,
           data = free, family = "binomial")

# summarize model
summary(mod)
```

The model coefficients and p-values suggest that the use of each feature is correlated with success.

Below we'll plot conversion rates by whether or not users used each feature in their first 14 days.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# filter data
filtered <- free %>% select(user_id, converted, active:engage_active)

# pivot to long format
rates <- filtered %>% 
  rename(publish = publish_active,
         engage = engage_active,
         analyze = analyze_active,
         all_buffer = active) %>% 
  pivot_longer(all_buffer:engage,
               names_to = "product",
               values_to = "did_use") %>% 
  group_by(product, did_use, converted) %>% 
  summarise(users = n_distinct(user_id)) %>% 
  mutate(percent = users / sum(users))

# plot conversion rates by whether used
rates %>% 
  filter(converted) %>% 
  buffplot(aes(x = did_use, y = percent, fill = product)) +
  geom_col(show.legend = F) +
  facet_wrap(~product) +
  scale_y_continuous(labels = percent) +
  labs(x = "Used in First 14 Days", y = "Free Conversion Rate")
```

Again we can see that usage of Engage and Analyze are correlated with conversion.

___ 

## Summary
Overall, this exploratory analysis confirms what we would suspect -- usage of Buffer's features is correlated with a higher likelihood of activating and purchasing a paid subscription. 

Usage of each feature is indicative of success, even when we try to control for users being active in general. 

There are a couple upgrade paths that have historically driven a large quantity of upgrades that are no longer performing well. Specifically, I would recommend looking more closely at these two paths and designing experiments to learn more about why they aren't performing as well:

 - `publish-composer-profileQueueLimit-showPaidPlans-1`
 - `publish-profileSidebar-addChannelButton-upgrade-1`
 
In addition to these two upgrade paths, I would recommend that we create a new upgrade path that is targeted specifically to users that want to add a team member. This is a key action that one can take and something that is highly correlated with success. 

The duration of new users' first sessions is highly correlated with success. In general, the longer they spend in the product during their first session, the more likely they are to activate and pay for a subscription. 

First session duration could be a useful early indicator of success that we can optimize for in growth experiments. 

In general, if users do not purchase a paid plan in their first 60 days, they are significantly less likely to do so in the future. The experience that new users have when signing up is highly influential and has a significant effect on their (and our) success with the product. 